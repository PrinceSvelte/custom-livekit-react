{"version":3,"file":"index.modern.js","sources":["../src/hooks/useParticipant.ts","../../../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/hooks/useRoom.ts","../src/components/VideoRenderer.tsx","../src/components/AudioRenderer.tsx"],"sourcesContent":["import {\n  ConnectionQuality,\n  LocalParticipant,\n  Participant,\n  ParticipantEvent,\n  Track,\n  TrackPublication,\n} from 'livekit-client';\nimport { useEffect, useState } from 'react';\n\nexport interface ParticipantState {\n  isSpeaking: boolean;\n  connectionQuality: ConnectionQuality;\n  isLocal: boolean;\n  metadata?: string;\n  publications: TrackPublication[];\n  subscribedTracks: TrackPublication[];\n  cameraPublication?: TrackPublication;\n  microphonePublication?: TrackPublication;\n  screenSharePublication?: TrackPublication;\n}\n\nexport function useParticipant(participant: Participant): ParticipantState {\n  const [isAudioMuted, setAudioMuted] = useState(false);\n  const [, setVideoMuted] = useState(false);\n  const [connectionQuality, setConnectionQuality] = useState<ConnectionQuality>(\n    participant.connectionQuality,\n  );\n  const [isSpeaking, setSpeaking] = useState(false);\n  const [metadata, setMetadata] = useState<string>();\n  const [publications, setPublications] = useState<TrackPublication[]>([]);\n  const [subscribedTracks, setSubscribedTracks] = useState<TrackPublication[]>([]);\n\n  const onPublicationsChanged = () => {\n    setPublications(Array.from(participant.tracks.values()));\n    setSubscribedTracks(\n      Array.from(participant.tracks.values()).filter((pub) => {\n        return pub.isSubscribed && pub.track !== undefined;\n      }),\n    );\n  };\n\n  useEffect(() => {\n    const onMuted = (pub: TrackPublication) => {\n      if (pub.kind === Track.Kind.Audio) {\n        setAudioMuted(true);\n      } else if (pub.kind === Track.Kind.Video) {\n        setVideoMuted(true);\n      }\n    };\n    const onUnmuted = (pub: TrackPublication) => {\n      if (pub.kind === Track.Kind.Audio) {\n        setAudioMuted(false);\n      } else if (pub.kind === Track.Kind.Video) {\n        setVideoMuted(false);\n      }\n    };\n    const onMetadataChanged = () => {\n      if (participant.metadata) {\n        setMetadata(participant.metadata);\n      }\n    };\n    const onIsSpeakingChanged = () => {\n      setSpeaking(participant.isSpeaking);\n    };\n    const onConnectionQualityUpdate = () => {\n      setConnectionQuality(participant.connectionQuality);\n    };\n\n    // register listeners\n    participant\n      .on(ParticipantEvent.TrackMuted, onMuted)\n      .on(ParticipantEvent.TrackUnmuted, onUnmuted)\n      .on(ParticipantEvent.ParticipantMetadataChanged, onMetadataChanged)\n      .on(ParticipantEvent.IsSpeakingChanged, onIsSpeakingChanged)\n      .on(ParticipantEvent.TrackPublished, onPublicationsChanged)\n      .on(ParticipantEvent.TrackUnpublished, onPublicationsChanged)\n      .on(ParticipantEvent.TrackSubscribed, onPublicationsChanged)\n      .on(ParticipantEvent.TrackUnsubscribed, onPublicationsChanged)\n      .on(ParticipantEvent.LocalTrackPublished, onPublicationsChanged)\n      .on(ParticipantEvent.LocalTrackUnpublished, onPublicationsChanged)\n      .on(ParticipantEvent.ConnectionQualityChanged, onConnectionQualityUpdate);\n\n    // set initial state\n    onMetadataChanged();\n    onIsSpeakingChanged();\n    onPublicationsChanged();\n\n    return () => {\n      // cleanup\n      participant\n        .off(ParticipantEvent.TrackMuted, onMuted)\n        .off(ParticipantEvent.TrackUnmuted, onUnmuted)\n        .off(ParticipantEvent.ParticipantMetadataChanged, onMetadataChanged)\n        .off(ParticipantEvent.IsSpeakingChanged, onIsSpeakingChanged)\n        .off(ParticipantEvent.TrackPublished, onPublicationsChanged)\n        .off(ParticipantEvent.TrackUnpublished, onPublicationsChanged)\n        .off(ParticipantEvent.TrackSubscribed, onPublicationsChanged)\n        .off(ParticipantEvent.TrackUnsubscribed, onPublicationsChanged)\n        .off(ParticipantEvent.LocalTrackPublished, onPublicationsChanged)\n        .off(ParticipantEvent.LocalTrackUnpublished, onPublicationsChanged)\n        .off(ParticipantEvent.ConnectionQualityChanged, onConnectionQualityUpdate);\n    };\n  }, [participant]);\n\n  let muted: boolean | undefined;\n  participant.audioTracks.forEach((pub) => {\n    muted = pub.isMuted;\n  });\n  if (muted === undefined) {\n    muted = true;\n  }\n  if (isAudioMuted !== muted) {\n    setAudioMuted(muted);\n  }\n\n  return {\n    isLocal: participant instanceof LocalParticipant,\n    isSpeaking,\n    connectionQuality,\n    publications,\n    subscribedTracks,\n    cameraPublication: participant.getTrack(Track.Source.Camera),\n    microphonePublication: participant.getTrack(Track.Source.Microphone),\n    screenSharePublication: participant.getTrack(Track.Source.ScreenShare),\n    metadata,\n  };\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import {\n  AudioTrack,\n  Participant,\n  RemoteTrack,\n  Room,\n  RoomEvent,\n  Track,\n  RoomOptions,\n  RoomConnectOptions,\n  ConnectionState,\n} from 'livekit-client';\nimport { useCallback, useEffect, useState } from 'react';\n\nexport interface RoomState {\n  connect: (url: string, token: string, options?: RoomConnectOptions) => Promise<Room | undefined>;\n  isConnecting: boolean;\n  room?: Room;\n  /* all participants in the room, including the local participant. */\n  participants: Participant[];\n  /* all subscribed audio tracks in the room, not including local participant. */\n  audioTracks: AudioTrack[];\n  error?: Error;\n  connectionState: ConnectionState;\n}\n\nexport function useRoom(roomOptions?: RoomOptions): RoomState {\n  const [room, setRoom] = useState<Room | undefined>();\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [error, setError] = useState<Error>();\n  const [participants, setParticipants] = useState<Participant[]>([]);\n  const [audioTracks, setAudioTracks] = useState<AudioTrack[]>([]);\n  const [connectionState, setConnectionState] = useState<ConnectionState>(\n    ConnectionState.Disconnected,\n  );\n\n  useEffect(() => {\n    setRoom(new Room(roomOptions));\n  }, []);\n\n  const connectFn = useCallback(\n    async (url: string, token: string, options?: RoomConnectOptions) => {\n      setIsConnecting(true);\n      try {\n        const onParticipantsChanged = () => {\n          if (!room) return;\n          const remotes = Array.from(room.participants.values());\n          const participants: Participant[] = [room.localParticipant];\n          participants.push(...remotes);\n          setParticipants(participants);\n        };\n        const onSubscribedTrackChanged = (track?: RemoteTrack) => {\n          // ordering may have changed, re-sort\n          onParticipantsChanged();\n          if ((track && track.kind !== Track.Kind.Audio) || !room) {\n            return;\n          }\n          const tracks: AudioTrack[] = [];\n          room.participants.forEach((p) => {\n            p.audioTracks.forEach((pub) => {\n              if (pub.audioTrack) {\n                tracks.push(pub.audioTrack);\n              }\n            });\n          });\n          setAudioTracks(tracks);\n        };\n\n        const onConnectionStateChanged = (state: ConnectionState) => {\n          setConnectionState(state);\n        };\n\n        if (!room) {\n          setError(new Error('room is not ready yet'));\n          return;\n        }\n\n        room.once(RoomEvent.Disconnected, () => {\n          room\n            .off(RoomEvent.ParticipantConnected, onParticipantsChanged)\n            .off(RoomEvent.ParticipantDisconnected, onParticipantsChanged)\n            .off(RoomEvent.ActiveSpeakersChanged, onParticipantsChanged)\n            .off(RoomEvent.TrackSubscribed, onSubscribedTrackChanged)\n            .off(RoomEvent.TrackUnsubscribed, onSubscribedTrackChanged)\n            .off(RoomEvent.LocalTrackPublished, onParticipantsChanged)\n            .off(RoomEvent.LocalTrackUnpublished, onParticipantsChanged)\n            .off(RoomEvent.AudioPlaybackStatusChanged, onParticipantsChanged)\n            .off(RoomEvent.ConnectionStateChanged, onConnectionStateChanged);\n        });\n        room\n          .on(RoomEvent.ParticipantConnected, onParticipantsChanged)\n          .on(RoomEvent.ParticipantDisconnected, onParticipantsChanged)\n          .on(RoomEvent.ActiveSpeakersChanged, onParticipantsChanged)\n          .on(RoomEvent.TrackSubscribed, onSubscribedTrackChanged)\n          .on(RoomEvent.TrackUnsubscribed, onSubscribedTrackChanged)\n          .on(RoomEvent.LocalTrackPublished, onParticipantsChanged)\n          .on(RoomEvent.LocalTrackUnpublished, onParticipantsChanged)\n          // trigger a state change by re-sorting participants\n          .on(RoomEvent.AudioPlaybackStatusChanged, onParticipantsChanged)\n          .on(RoomEvent.ConnectionStateChanged, onConnectionStateChanged);\n\n        await room.connect(url, token, options);\n        setIsConnecting(false);\n        onSubscribedTrackChanged();\n        setError(undefined);\n        return room;\n      } catch (error) {\n        setIsConnecting(false);\n        if (error instanceof Error) {\n          setError(error);\n        } else {\n          setError(new Error('an error has occured'));\n        }\n\n        return undefined;\n      }\n    },\n    [room],\n  );\n\n  return {\n    connect: connectFn,\n    isConnecting,\n    room,\n    error,\n    participants,\n    audioTracks,\n    connectionState,\n  };\n}\n","import { Property } from 'csstype';\nimport { Track } from 'livekit-client';\nimport React, { CSSProperties, useCallback, useEffect, useRef } from 'react';\n\nexport interface VideoRendererProps {\n  track: Track;\n  isLocal: boolean;\n  /**\n   * Mirror the video on the y axis.\n   * Is `true` by default for local, front-facing (and undetermined facing) media tracks,\n   * unless overriden by this setting */\n  isMirrored?: boolean;\n  objectFit?: Property.ObjectFit;\n  className?: string;\n  width?: Property.Width;\n  height?: Property.Height;\n  onSizeChanged?: (width: number, height: number) => void;\n}\n\nexport const VideoRenderer = ({\n  track,\n  isLocal,\n  isMirrored,\n  objectFit,\n  className,\n  onSizeChanged,\n  width,\n  height,\n}: VideoRendererProps) => {\n  const ref = useRef<HTMLVideoElement>(null);\n\n  useEffect(() => {\n    const el = ref.current;\n    if (!el) {\n      return;\n    }\n    el.muted = true;\n    track.attach(el);\n    return () => {\n      track.detach(el);\n    };\n  }, [track, ref]);\n\n  const handleResize = useCallback((ev: UIEvent) => {\n    if (ev.target instanceof HTMLVideoElement) {\n      if (onSizeChanged) {\n        onSizeChanged(ev.target.videoWidth, ev.target.videoHeight);\n      }\n    }\n  }, []);\n\n  useEffect(() => {\n    const el = ref.current;\n    if (el) {\n      el.addEventListener('resize', handleResize);\n    }\n    return () => {\n      el?.removeEventListener('resize', handleResize);\n    };\n  }, [ref]);\n\n  const style: CSSProperties = {\n    width: width,\n    height: height,\n  };\n\n  const isFrontFacingOrUnknown = track.mediaStreamTrack?.getSettings().facingMode !== 'environment';\n  if (isMirrored || (isMirrored === undefined && isLocal && isFrontFacingOrUnknown)) {\n    style.transform = 'rotateY(180deg)';\n  }\n\n  if (objectFit) {\n    style.objectFit = objectFit;\n  }\n\n  return <video ref={ref} className={className} style={style} />;\n};\n","import { Track } from 'livekit-client';\nimport { useEffect, useRef } from 'react';\n\nexport interface AudioTrackProps {\n  track: Track;\n  isLocal: boolean;\n}\n\nexport const AudioRenderer = ({ track, isLocal }: AudioTrackProps) => {\n  const audioEl = useRef<HTMLAudioElement>();\n\n  useEffect(() => {\n    if (isLocal) {\n      // don't play own audio\n      return;\n    }\n    audioEl.current = track.attach();\n    if (track.sid) {\n      audioEl.current.setAttribute('data-audio-track-id', track.sid);\n    }\n    return () => track.detach().forEach((el) => el.remove());\n  }, [track, isLocal]);\n\n  // TODO: allow set sink id\n  return null;\n};\n"],"names":["useParticipant","participant","useState","isAudioMuted","setAudioMuted","setVideoMuted","connectionQuality","setConnectionQuality","isSpeaking","setSpeaking","metadata","setMetadata","publications","setPublications","subscribedTracks","setSubscribedTracks","onPublicationsChanged","Array","from","tracks","values","filter","pub","isSubscribed","track","undefined","useEffect","onMuted","kind","Track","Kind","Audio","Video","onUnmuted","onMetadataChanged","onIsSpeakingChanged","onConnectionQualityUpdate","on","ParticipantEvent","TrackMuted","TrackUnmuted","ParticipantMetadataChanged","IsSpeakingChanged","TrackPublished","TrackUnpublished","TrackSubscribed","TrackUnsubscribed","LocalTrackPublished","LocalTrackUnpublished","ConnectionQualityChanged","off","muted","audioTracks","forEach","isMuted","isLocal","LocalParticipant","cameraPublication","getTrack","Source","Camera","microphonePublication","Microphone","screenSharePublication","ScreenShare","_iteratorSymbol","Symbol","iterator","_asyncIteratorSymbol","asyncIterator","_catch","body","recover","result","e","then","useRoom","roomOptions","room","setRoom","isConnecting","setIsConnecting","error","setError","participants","setParticipants","setAudioTracks","ConnectionState","Disconnected","connectionState","setConnectionState","Room","connectFn","useCallback","url","token","options","onParticipantsChanged","remotes","localParticipant","push","onSubscribedTrackChanged","p","audioTrack","onConnectionStateChanged","state","Error","once","RoomEvent","ParticipantConnected","ParticipantDisconnected","ActiveSpeakersChanged","AudioPlaybackStatusChanged","ConnectionStateChanged","connect","VideoRenderer","isMirrored","objectFit","className","onSizeChanged","width","height","ref","useRef","el","current","attach","detach","handleResize","ev","target","HTMLVideoElement","videoWidth","videoHeight","addEventListener","removeEventListener","style","isFrontFacingOrUnknown","mediaStreamTrack","getSettings","facingMode","transform","React","AudioRenderer","audioEl","sid","setAttribute","remove"],"mappings":"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"}